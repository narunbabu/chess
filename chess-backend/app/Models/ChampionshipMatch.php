<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Support\Facades\Log;
use App\Enums\ChampionshipMatchStatus as ChampionshipMatchStatusEnum;
use App\Enums\ChampionshipRoundType as ChampionshipRoundTypeEnum;
use App\Enums\ChampionshipResultType as ChampionshipResultTypeEnum;

class ChampionshipMatch extends Model
{
    use HasFactory;

    protected $fillable = [
        'championship_id',
        'round_number',
        'round_type',       // Virtual attribute (mutator converts to round_type_id)
        'round_type_id',    // FK to championship_round_types table
        'player1_id',
        'player2_id',
        'white_player_id',  // Player assigned white pieces
        'black_player_id',  // Player assigned black pieces
        'color_assignment_method', // Method used: balanced, alternate, random
        'auto_generated',   // Auto-generated by system
        // Placeholder match support
        'is_placeholder',   // Match with TBD players based on rankings
        'placeholder_positions', // JSON: rank positions (e.g., {"player1": "rank_1", "player2": "rank_2"})
        'players_assigned_at', // When actual players were assigned to placeholder
        'determined_by_round', // Which round's results determine this match's players
        'game_id',
        'scheduled_at',
        'deadline',
        'invitation_sent_at',
        'invitation_accepted_at',
        'invitation_status', // pending, accepted, declined, expired
        'winner_id',
        'result_type',      // Virtual attribute (mutator converts to result_type_id)
        'result_type_id',   // FK to championship_result_types table
        'status',           // Virtual attribute (mutator converts to status_id)
        'status_id',        // FK to championship_match_statuses table
        // Scheduling fields
        'scheduled_time',
        'game_timeout',
        'scheduling_status',
        'can_schedule_early',
        'scheduling_notes',
        // Test-compat fields
        'result',
        'completed_at',
        'moves',
    ];

    protected $casts = [
        'championship_id' => 'integer',
        'round_number' => 'integer',
        'round_type_id' => 'integer',
        'player1_id' => 'integer',
        'player2_id' => 'integer',
        'white_player_id' => 'integer',
        'black_player_id' => 'integer',
        'color_assignment_method' => 'string',
        'auto_generated' => 'boolean',
        // Placeholder match casts
        'is_placeholder' => 'boolean',
        'placeholder_positions' => 'array',
        'players_assigned_at' => 'datetime',
        'determined_by_round' => 'integer',
        'game_id' => 'integer',
        'scheduled_at' => 'datetime',
        'deadline' => 'datetime',
        'invitation_sent_at' => 'datetime',
        'invitation_accepted_at' => 'datetime',
        'invitation_status' => 'string',
        'winner_id' => 'integer',
        'result_type_id' => 'integer',
        'status_id' => 'integer',
        // Scheduling field casts
        'scheduled_time' => 'datetime',
        'game_timeout' => 'datetime',
        'can_schedule_early' => 'boolean',
        'completed_at' => 'datetime',
    ];

    /**
     * Append accessor attributes to JSON serialization
     */
    protected $appends = [
        'status',
        'round_type',
        'result_type',
    ];

    // Relationships

    /**
     * The championship this match belongs to
     */
    public function championship()
    {
        return $this->belongsTo(Championship::class);
    }

    /**
     * Player 1 (legacy support)
     */
    public function player1()
    {
        return $this->belongsTo(User::class, 'player1_id');
    }

    /**
     * Player 2 (legacy support)
     */
    public function player2()
    {
        return $this->belongsTo(User::class, 'player2_id');
    }

    /**
     * White player
     */
    public function whitePlayer()
    {
        return $this->belongsTo(User::class, 'white_player_id');
    }

    /**
     * Black player
     */
    public function blackPlayer()
    {
        return $this->belongsTo(User::class, 'black_player_id');
    }

    /**
     * The game associated with this match
     */
    public function game()
    {
        return $this->belongsTo(Game::class);
    }

    /**
     * The winner of the match
     */
    public function winner()
    {
        return $this->belongsTo(User::class, 'winner_id');
    }

    /**
     * Relationship to ChampionshipMatchStatus lookup table
     */
    public function statusRelation()
    {
        return $this->belongsTo(ChampionshipMatchStatus::class, 'status_id');
    }

    /**
     * Relationship to ChampionshipRoundType lookup table
     */
    public function roundTypeRelation()
    {
        return $this->belongsTo(ChampionshipRoundType::class, 'round_type_id');
    }

    /**
     * Alias for roundTypeRelation for consistency
     */
    public function roundType()
    {
        return $this->roundTypeRelation();
    }

    /**
     * Relationship to ChampionshipResultType lookup table
     */
    public function resultTypeRelation()
    {
        return $this->belongsTo(ChampionshipResultType::class, 'result_type_id');
    }

    /**
     * Alias for resultTypeRelation for consistency
     */
    public function resultType()
    {
        return $this->resultTypeRelation();
    }

    /**
     * The white player for this match
     */
    public function white_player()
    {
        return $this->belongsTo(User::class, 'white_player_id');
    }

    /**
     * The black player for this match
     */
    public function black_player()
    {
        return $this->belongsTo(User::class, 'black_player_id');
    }

    /**
     * Get the scheduling proposals for this match
     */
    public function schedules()
    {
        return $this->hasMany(ChampionshipMatchSchedule::class, 'championship_match_id');
    }

    /**
     * Get the current active schedule proposal
     */
    public function currentSchedule()
    {
        return $this->schedules()
            ->whereIn('status', ['proposed', 'accepted', 'alternative_proposed'])
            ->latest()
            ->first();
    }

    // Mutators & Accessors

    /**
     * Mutator: Convert status string/enum to status_id FK
     */
    public function setStatusAttribute($value)
    {
        if ($value instanceof ChampionshipMatchStatusEnum) {
            $code = $value->value;
        } else {
            $code = $value;
        }

        // Map test shorthand status names to actual status codes
        $statusMap = [
            'scheduled' => 'pending',
        ];
        $code = $statusMap[$code] ?? $code;

        $this->attributes['status_id'] = ChampionshipMatchStatus::getIdByCode($code);
    }

    /**
     * Accessor: Read status code from relationship
     */
    public function getStatusAttribute(): string
    {
        if (isset($this->attributes['status_id'])) {
            return $this->statusRelation?->code ??
                   ChampionshipMatchStatus::find($this->attributes['status_id'])?->code ??
                   'pending';
        }

        return 'pending';
    }

    /**
     * Mutator: Convert round type string/enum to round_type_id FK
     */
    public function setRoundTypeAttribute($value)
    {
        if ($value instanceof ChampionshipRoundTypeEnum) {
            $code = $value->value;
        } else {
            $code = $value;
        }

        $this->attributes['round_type_id'] = ChampionshipRoundType::getIdByCode($code);
    }

    /**
     * Accessor: Read round type code from relationship
     */
    public function getRoundTypeAttribute(): string
    {
        if (isset($this->attributes['round_type_id'])) {
            return $this->roundTypeRelation?->code ??
                   ChampionshipRoundType::find($this->attributes['round_type_id'])?->code ??
                   'swiss';
        }

        return 'swiss';
    }

    /**
     * Mutator: Convert result type string/enum to result_type_id FK
     */
    public function setResultTypeAttribute($value)
    {
        if ($value === null) {
            $this->attributes['result_type_id'] = null;
            return;
        }

        if ($value instanceof ChampionshipResultTypeEnum) {
            $code = $value->value;
        } else {
            $code = $value;
        }

        $this->attributes['result_type_id'] = ChampionshipResultType::getIdByCode($code);
    }

    /**
     * Accessor: Read result type code from relationship
     */
    public function getResultTypeAttribute(): ?string
    {
        if (isset($this->attributes['result_type_id']) && $this->attributes['result_type_id'] !== null) {
            return $this->resultTypeRelation?->code ??
                   ChampionshipResultType::find($this->attributes['result_type_id'])?->code;
        }

        return null;
    }

    // Scopes

    /**
     * Scope: Pending matches
     */
    public function scopePending($query)
    {
        return $query->where('status_id', ChampionshipMatchStatusEnum::PENDING->getId());
    }

    /**
     * Scope: In progress matches
     */
    public function scopeInProgress($query)
    {
        return $query->where('status_id', ChampionshipMatchStatusEnum::IN_PROGRESS->getId());
    }

    /**
     * Scope: Completed matches
     */
    public function scopeCompleted($query)
    {
        return $query->where('status_id', ChampionshipMatchStatusEnum::COMPLETED->getId());
    }

    /**
     * Scope: Not completed matches (pending, in_progress, scheduled, etc.)
     */
    public function scopeWhereNotCompleted($query)
    {
        return $query->where('status_id', '!=', ChampionshipMatchStatusEnum::COMPLETED->getId());
    }

    /**
     * Scope: Matches for a specific round
     */
    public function scopeForRound($query, ?int $roundNumber)
    {
        if ($roundNumber === null) {
            return $query;
        }
        return $query->where('round_number', $roundNumber);
    }

    /**
     * Scope: Expired matches
     */
    public function scopeExpired($query)
    {
        return $query->where('deadline', '<', now())
                    ->where('status_id', '!=', ChampionshipMatchStatusEnum::COMPLETED->getId());
    }

    // Helper Methods

    /**
     * Get status as enum
     */
    public function getStatusEnum(): ChampionshipMatchStatusEnum
    {
        return ChampionshipMatchStatusEnum::from($this->status);
    }

    /**
     * Get round type as enum
     */
    public function getRoundTypeEnum(): ChampionshipRoundTypeEnum
    {
        return ChampionshipRoundTypeEnum::from($this->round_type);
    }

    /**
     * Get result type as enum (nullable)
     */
    public function getResultTypeEnum(): ?ChampionshipResultTypeEnum
    {
        return $this->result_type ? ChampionshipResultTypeEnum::from($this->result_type) : null;
    }

    /**
     * Mark match as completed
     */
    public function markAsCompleted(int $winnerId, string $resultType): void
    {
        $this->update([
            'winner_id' => $winnerId,
            'result_type' => $resultType,
            'status' => ChampionshipMatchStatusEnum::COMPLETED->value,
        ]);

        // ðŸŽ¯ CRITICAL FIX: Trigger automatic round progression for Swiss tournaments
        $this->triggerAutomaticRoundProgression();
    }

    /**
     * Trigger automatic round progression for Swiss tournaments
     */
    private function triggerAutomaticRoundProgression(): void
    {
        $championship = $this->championship;

        // Only proceed for Swiss tournaments
        if (!$championship || !$championship->getFormatEnum()->isSwiss()) {
            return;
        }

        // Check if this was the last match to complete in the current round
        $roundNumber = $this->round_number;
        $totalMatchesInRound = $championship->matches()->where('round_number', $roundNumber)->count();
        $completedMatchesInRound = $championship->matches()
            ->where('round_number', $roundNumber)
            ->where('status_id', ChampionshipMatchStatusEnum::COMPLETED->getId())
            ->count();

        if ($completedMatchesInRound === $totalMatchesInRound) {
            Log::info("Round completed - triggering next round activation", [
                'championship_id' => $championship->id,
                'completed_round' => $roundNumber,
                'total_matches' => $totalMatchesInRound,
                'completed_matches' => $completedMatchesInRound
            ]);

            // Activate the next round by assigning players to placeholder matches
            $this->activateNextSwissRound($championship, $roundNumber + 1);
        }
    }

    /**
     * Activate the next Swiss round by assigning players to placeholder matches
     */
    private function activateNextSwissRound(Championship $championship, int $nextRoundNumber): void
    {
        try {
            $placeholderMatches = $championship->matches()
                ->where('round_number', $nextRoundNumber)
                ->where('status_id', ChampionshipMatchStatusEnum::PENDING->getId())
                ->where('is_placeholder', true)
                ->whereNull('players_assigned_at')
                ->get();

            if ($placeholderMatches->isEmpty()) {
                Log::info("No placeholder matches found for next round", [
                    'championship_id' => $championship->id,
                    'next_round' => $nextRoundNumber
                ]);
                return;
            }

            Log::info("Activating next Swiss round", [
                'championship_id' => $championship->id,
                'next_round' => $nextRoundNumber,
                'placeholder_matches' => $placeholderMatches->count()
            ]);

            // Use the PlaceholderMatchAssignmentService to assign players
            $assignmentService = app(\App\Services\PlaceholderMatchAssignmentService::class);
            $assignmentService->assignPlayersToPlaceholderMatches($championship, $nextRoundNumber);

            Log::info("Next Swiss round activated successfully", [
                'championship_id' => $championship->id,
                'activated_round' => $nextRoundNumber
            ]);

        } catch (\Exception $e) {
            Log::error("Failed to activate next Swiss round", [
                'championship_id' => $championship->id,
                'next_round' => $nextRoundNumber,
                'error' => $e->getMessage()
            ]);
        }
    }

    /**
     * Handle forfeit by player 1
     */
    public function forfeitPlayer1(): void
    {
        $this->markAsCompleted(
            $this->player2_id,
            ChampionshipResultTypeEnum::FORFEIT_PLAYER1->value
        );
    }

    /**
     * Handle forfeit by player 2
     */
    public function forfeitPlayer2(): void
    {
        $this->markAsCompleted(
            $this->player1_id,
            ChampionshipResultTypeEnum::FORFEIT_PLAYER2->value
        );
    }

    /**
     * Handle double forfeit
     */
    public function doubleForfeit(): void
    {
        $this->update([
            'winner_id' => null,
            'result_type' => ChampionshipResultTypeEnum::DOUBLE_FORFEIT->value,
            'status' => ChampionshipMatchStatusEnum::COMPLETED->value,
        ]);
    }

    /**
     * Check if match has expired
     */
    public function hasExpired(): bool
    {
        return now()->greaterThan($this->deadline) &&
               !$this->getStatusEnum()->isFinished();
    }

  
    /**
     * Get opponent for a given player (using new color assignments)
     */
    public function getOpponent(int $userId): ?User
    {
        if ($this->white_player_id === $userId) {
            return $this->blackPlayer;
        }
        if ($this->black_player_id === $userId) {
            return $this->whitePlayer;
        }

        // Fallback to legacy player1/player2 for backward compatibility
        if ($this->player1_id === $userId) {
            return $this->player2;
        }
        if ($this->player2_id === $userId) {
            return $this->player1;
        }

        return null;
    }

    /**
     * Get player's color in this match
     */
    public function getPlayerColor(int $userId): ?string
    {
        if ($this->white_player_id === $userId) {
            return 'white';
        }
        if ($this->black_player_id === $userId) {
            return 'black';
        }

        // Fallback to legacy player1/player2 for backward compatibility
        if ($this->player1_id === $userId) {
            return 'white'; // Assume player1 is white in legacy data
        }
        if ($this->player2_id === $userId) {
            return 'black'; // Assume player2 is black in legacy data
        }

        return null;
    }

    /**
     * Check if player is involved in this match (using new color assignments)
     */
    public function hasPlayer(int $userId): bool
    {
        return $this->white_player_id === $userId ||
               $this->black_player_id === $userId ||
               $this->player1_id === $userId ||
               $this->player2_id === $userId; // Include legacy support
    }

    /**
     * Assign colors to players
     */
    public function assignColors(int $whitePlayerId, int $blackPlayerId): void
    {
        $this->update([
            'white_player_id' => $whitePlayerId,
            'black_player_id' => $blackPlayerId,
            'player1_id' => $whitePlayerId, // Update legacy fields too
            'player2_id' => $blackPlayerId,
        ]);
    }

    /**
     * Check if match has both players assigned with colors
     */
    public function hasCompleteColorAssignment(): bool
    {
        return !is_null($this->white_player_id) && !is_null($this->black_player_id);
    }

    /**
     * Mark invitation as sent
     */
    public function markInvitationSent(): void
    {
        $this->update([
            'invitation_sent_at' => now(),
            'invitation_status' => 'pending'
        ]);
    }

    /**
     * Mark invitation as accepted
     */
    public function markInvitationAccepted(): void
    {
        $this->update([
            'invitation_accepted_at' => now(),
            'invitation_status' => 'accepted',
            'status' => 'scheduled'
        ]);
    }

    /**
     * Mark invitation as declined
     */
    public function markInvitationDeclined(): void
    {
        $this->update([
            'invitation_status' => 'declined',
            'status' => 'pending'
        ]);
    }

    /**
     * Check if invitation is pending
     */
    public function isInvitationPending(): bool
    {
        return $this->invitation_status === 'pending';
    }

    /**
     * Check if invitation was accepted
     */
    public function isInvitationAccepted(): bool
    {
        return $this->invitation_status === 'accepted';
    }

    /**
     * Get match duration in minutes
     */
    public function getDurationMinutes(): ?int
    {
        if (!$this->scheduled_at || !$this->completed_at) {
            return null;
        }

        return $this->scheduled_at->diffInMinutes($this->completed_at);
    }

    // Placeholder Match Methods

    /**
     * Check if this is a placeholder match
     */
    public function isPlaceholder(): bool
    {
        return $this->is_placeholder === true;
    }

    /**
     * Check if placeholder has been assigned players
     */
    public function hasAssignedPlayers(): bool
    {
        return $this->isPlaceholder() &&
               !is_null($this->players_assigned_at) &&
               !is_null($this->player1_id) &&
               !is_null($this->player2_id);
    }

    /**
     * Get placeholder position for a player slot
     *
     * @param string $slot 'player1' or 'player2'
     * @return string|null e.g., 'rank_1', 'rank_2'
     */
    public function getPlaceholderPosition(string $slot): ?string
    {
        if (!$this->isPlaceholder() || !$this->placeholder_positions) {
            return null;
        }

        return $this->placeholder_positions[$slot] ?? null;
    }

    /**
     * Assign players to placeholder match based on rankings
     *
     * @param int $player1Id
     * @param int $player2Id
     * @param int|null $whitePlayerId Optional: if colors already determined
     * @param int|null $blackPlayerId Optional: if colors already determined
     */
    public function assignPlaceholderPlayers(
        int $player1Id,
        int $player2Id,
        ?int $whitePlayerId = null,
        ?int $blackPlayerId = null
    ): void {
        if (!$this->isPlaceholder()) {
            throw new \LogicException('Cannot assign players to non-placeholder match');
        }

        $updateData = [
            'player1_id' => $player1Id,
            'player2_id' => $player2Id,
            'players_assigned_at' => now(),
            'is_placeholder' => false, // ðŸŽ¯ CRITICAL FIX: Mark as no longer a placeholder
            'status_id' => \App\Enums\ChampionshipMatchStatus::PENDING->getId(), // Set to pending for play
        ];

        // Assign colors if provided
        if ($whitePlayerId && $blackPlayerId) {
            $updateData['white_player_id'] = $whitePlayerId;
            $updateData['black_player_id'] = $blackPlayerId;
        }

        $this->update($updateData);
    }

    /**
     * Scope: Get placeholder matches for a specific round
     */
    public function scopePlaceholder($query)
    {
        return $query->where('is_placeholder', true);
    }

    /**
     * Scope: Get unassigned placeholder matches
     */
    public function scopeUnassignedPlaceholders($query)
    {
        return $query->where('is_placeholder', true)
                    ->whereNull('players_assigned_at');
    }

    /**
     * Scope: Get placeholder matches determined by a specific round
     */
    public function scopeDeterminedByRound($query, int $roundNumber)
    {
        return $query->where('is_placeholder', true)
                    ->where('determined_by_round', $roundNumber);
    }

    /**
     * Get human-readable placeholder description
     */
    public function getPlaceholderDescription(): ?string
    {
        if (!$this->isPlaceholder() || !$this->placeholder_positions) {
            return null;
        }

        $pos1 = $this->placeholder_positions['player1'] ?? 'TBD';
        $pos2 = $this->placeholder_positions['player2'] ?? 'TBD';

        // Convert 'rank_1' to 'Rank #1'
        $pos1Display = ucfirst(str_replace('_', ' #', $pos1));
        $pos2Display = ucfirst(str_replace('_', ' #', $pos2));

        return "{$pos1Display} vs {$pos2Display}";
    }

    /**
     * Check if a player can play in this match based on round progression
     * Players can only play in round N if they've completed their match in round N-1
     *
     * @param int $userId
     * @return array ['canPlay' => bool, 'reason' => string|null]
     */
    public function canPlayerPlay(int $userId): array
    {
        // ðŸŽ¯ CRITICAL FIX: Check if this match is a placeholder without assigned players
        if ($this->isPlaceholder() && !$this->hasAssignedPlayers()) {
            return ['canPlay' => false, 'reason' => 'Match players not yet determined'];
        }

        // Players can always play round 1 (if players are assigned)
        if ($this->round_number === 1) {
            return ['canPlay' => true, 'reason' => null];
        }

        // Check if this player is actually in this match (support both player ID field formats)
        $isPlayer1 = $this->player1_id === $userId;
        $isPlayer2 = $this->player2_id === $userId;
        $isWhitePlayer = $this->white_player_id === $userId;
        $isBlackPlayer = $this->black_player_id === $userId;

        if (!$isPlayer1 && !$isPlayer2 && !$isWhitePlayer && !$isBlackPlayer) {
            return ['canPlay' => false, 'reason' => 'You are not a participant in this match'];
        }

        // Check if player has completed their previous round match (support both player ID field formats)
        $previousRoundMatch = self::where('championship_id', $this->championship_id)
            ->where('round_number', $this->round_number - 1)
            ->where(function ($query) use ($userId) {
                $query->where('player1_id', $userId)
                    ->orWhere('player2_id', $userId)
                    ->orWhere('white_player_id', $userId)
                    ->orWhere('black_player_id', $userId);
            })
            ->first();

        if (!$previousRoundMatch) {
            return ['canPlay' => false, 'reason' => 'Previous round match not found'];
        }

        // Use status_id for reliable comparison
        if ($previousRoundMatch->status_id !== ChampionshipMatchStatusEnum::COMPLETED->getId()) {
            return ['canPlay' => false, 'reason' => 'You must complete your Round ' . ($this->round_number - 1) . ' match first'];
        }

        // Check if player qualified (didn't get eliminated)
        // If the player lost and it's an elimination tournament, they can't play
        if ($previousRoundMatch->winner_id && $previousRoundMatch->winner_id !== $userId) {
            $championship = $this->championship;
            // For knockout tournaments, losing means elimination
            if ($championship && $championship->format === 'single_elimination') {
                return ['canPlay' => false, 'reason' => 'You were eliminated in Round ' . ($this->round_number - 1)];
            }
        }

        return ['canPlay' => true, 'reason' => null];
    }

    /**
     * Get round statistics for leaderboard
     *
     * @param int $championshipId
     * @param int $roundNumber
     * @return array
     */
    public static function getRoundLeaderboard(int $championshipId, int $roundNumber): array
    {
        $matches = self::where('championship_id', $championshipId)
            ->where('round_number', '<=', $roundNumber)
            ->completed()  // Use scope instead of direct status comparison
            ->with(['player1', 'player2', 'white_player', 'black_player', 'winner'])
            ->get();

        $playerStats = [];

        foreach ($matches as $match) {
            // Determine which player ID fields to use
            $player1Id = $match->player1_id ?: $match->white_player_id;
            $player2Id = $match->player2_id ?: $match->black_player_id;

            // Determine which user relationships to use
            $player1User = $match->player1 ?: $match->white_player;
            $player2User = $match->player2 ?: $match->black_player;

            // Skip if we don't have player IDs
            if (!$player1Id) continue;

            // Initialize player1 stats
            if (!isset($playerStats[$player1Id])) {
                $playerStats[$player1Id] = [
                    'user' => $player1User,
                    'played' => 0,
                    'won' => 0,
                    'lost' => 0,
                    'draw' => 0,
                    'points' => 0,
                ];
            }

            // Initialize player2 stats
            if ($player2Id && !isset($playerStats[$player2Id])) {
                $playerStats[$player2Id] = [
                    'user' => $player2User,
                    'played' => 0,
                    'won' => 0,
                    'lost' => 0,
                    'draw' => 0,
                    'points' => 0,
                ];
            }

            // Update stats
            $playerStats[$player1Id]['played']++;
            if ($player2Id) {
                $playerStats[$player2Id]['played']++;
            }

            if ($match->winner_id) {
                // Someone won
                if ($match->winner_id === $player1Id) {
                    $playerStats[$player1Id]['won']++;
                    $playerStats[$player1Id]['points'] += 1.0;
                    if ($player2Id) {
                        $playerStats[$player2Id]['lost']++;
                    }
                } elseif ($match->winner_id === $player2Id) {
                    $playerStats[$player2Id]['won']++;
                    $playerStats[$player2Id]['points'] += 1.0;
                    $playerStats[$player1Id]['lost']++;
                }
            } else {
                // Draw
                $playerStats[$player1Id]['draw']++;
                $playerStats[$player1Id]['points'] += 0.5;
                if ($player2Id) {
                    $playerStats[$player2Id]['draw']++;
                    $playerStats[$player2Id]['points'] += 0.5;
                }
            }
        }

        // Sort by points (descending), then by wins (descending)
        uasort($playerStats, function ($a, $b) {
            if ($a['points'] === $b['points']) {
                return $b['won'] <=> $a['won'];
            }
            return $b['points'] <=> $a['points'];
        });

        // Add rank
        $rank = 1;
        foreach ($playerStats as &$stats) {
            $stats['rank'] = $rank++;
        }

        return array_values($playerStats);
    }
}
