import React, { useMemo } from 'react';import type { GameResult, CurrentUser, RatingUpdate } from '../types';import chessPlayingKids from '../assets/images/chess-playing-kids-crop.png';import logo from '../assets/images/logo.png';import './GameEndCard.css';interface GameEndCardProps {  result: GameResult;  user: CurrentUser;  ratingUpdate?: RatingUpdate;  className?: string;  score?: number;  opponentScore?: number;  playerColor?: string;  isMultiplayer?: boolean;  computerLevel?: number;  isAuthenticated?: boolean;}const GameEndCard: React.FC<GameEndCardProps> = ({  result,  user,  ratingUpdate,  className = '',  score,  opponentScore,  playerColor,  isMultiplayer,  computerLevel,  isAuthenticated}) => {  const {    isPlayerWin,    isDraw,    playersInfo,    resultText,    icon,    title,    gameDurationText  } = useMemo(() => {    // Debug logging to understand user data issues    console.log('GameEndCard user data debug:', {      user: user,      isAuthenticated: isAuthenticated,      playerColor: playerColor,      resultUserId: result.user_id,      resultWinnerUserId: result.winner_user_id,      gameMode: result.game_mode    });    const userId = user?.id;    const hasUser = !!userId && isAuthenticated;    // Fix result detection - handle multiple formats properly    let isPlayerWin = false;    if (userId && result.winner_user_id) {      isPlayerWin = result.winner_user_id === userId;    } else if (result.result?.winner === 'player' && result.user_id === userId) {      isPlayerWin = true;    } else if (result.player_color && result.result?.winner === 'player') {      // For computer games, check if player color matches winner      isPlayerWin = true;    }    const isDraw = result.result === '1/2-1/2' || result.end_reason === 'draw' || result.result?.status === 'draw';    // Handle cases where white_player and black_player might not exist    const isComputerGame = result.game_mode === 'computer' || result.game_mode === 'local_ai';    const playerIsWhite = result.player_color === 'w';    // Use the provided computerLevel if available, otherwise fall back to result.computer_level    const effectiveComputerLevel = computerLevel !== undefined ? computerLevel : result.computer_level;    console.log('Player assignment debug:', {      isComputerGame,      playerIsWhite,      computerLevel,      effectiveComputerLevel,      userName: user?.name,      opponentName: result.opponent_name    });    const white_player = result.white_player || {      id: playerIsWhite ? result.user_id : null,      name: playerIsWhite ? (user?.name || 'Player') : (isComputerGame ? `Computer Level ${effectiveComputerLevel || 8}` : (result.opponent_name || 'Opponent')),      rating: playerIsWhite ? (user?.rating || 1200) : (isComputerGame ? (effectiveComputerLevel ? 1000 + (effectiveComputerLevel * 100) : 1800) : 1200),      is_provisional: playerIsWhite ? (user?.is_provisional || false) : false,      avatar_url: playerIsWhite ? user?.avatar_url : (isComputerGame ? 'ðŸ¤–' : null),      isComputer: playerIsWhite ? false : isComputerGame    };    const black_player = result.black_player || {      id: !playerIsWhite ? result.user_id : null,      name: !playerIsWhite ? (user?.name || 'Player') : (isComputerGame ? `Computer Level ${effectiveComputerLevel || 8}` : (result.opponent_name || 'Opponent')),      rating: !playerIsWhite ? (user?.rating || 1200) : (isComputerGame ? (effectiveComputerLevel ? 1000 + (effectiveComputerLevel * 100) : 1800) : 1200),      is_provisional: !playerIsWhite ? (user?.is_provisional || false) : false,      avatar_url: !playerIsWhite ? user?.avatar_url : (isComputerGame ? 'ðŸ¤–' : null),      isComputer: !playerIsWhite ? false : isComputerGame    };    const isUserWhite = playerIsWhite;    const isUserBlack = !playerIsWhite;    const userPlayer = isUserWhite ? white_player : black_player;    const opponentPlayer = isUserWhite ? black_player : white_player;    const playersInfo = { white_player, black_player, userPlayer, opponentPlayer, isUserWhite, isUserBlack, hasUser };    let resultText;    if (isDraw) {      resultText = `Draw by ${result.end_reason}`;    } else {      // Determine winner name based on available data      let winnerName;      if (result.winner_player === 'white' || (result.player_color === 'w' && result.result?.winner === 'player')) {        winnerName = white_player.name;      } else if (result.winner_player === 'black' || (result.player_color === 'b' && result.result?.winner === 'player')) {        winnerName = black_player.name;      } else {        winnerName = white_player.name; // Default fallback      }      const reasonText = result.end_reason || result.result?.details || 'game completion';      if (userId && isPlayerWin) {        resultText = `You defeated ${opponentPlayer?.name || 'the opponent'} by ${reasonText}!`;      } else if (userId && !isPlayerWin) {        resultText = `${winnerName} defeated you by ${reasonText}!`;      } else {        // Guest/viewer mode        resultText = `${winnerName} won by ${reasonText}!`;      }    }        const icon = isDraw ? "ðŸ¤" : (isPlayerWin ? "ðŸ†" : "ðŸ’”");    const title = isDraw ? "Draw!" : (isPlayerWin ? "Victory!" : "Defeat");    // Handle duration calculation with fallbacks    let gameDurationText = '0m 0s';    try {      let durationSeconds = 0;      // Debug logging to help identify the issue      console.log('GameEndCard duration calculation:', {        has_moves: !!result.moves,        moves_type: typeof result.moves,        moves_length: Array.isArray(result.moves) ? result.moves.length : 'N/A',        last_move_at: result.last_move_at,        created_at: result.created_at,        played_at: result.played_at,        ended_at: result.ended_at      });      // Method 1: Calculate from moves (most accurate - actual play time)      if (result.moves) {        let moves = [];        // Handle different move formats        if (typeof result.moves === 'string') {          try {            // Try to parse if it's a JSON string            moves = JSON.parse(result.moves);          } catch {            // If not JSON, it might be in compact format "e4,2.52;Nf6,0.98;..."            const moveEntries = result.moves.split(';');            moveEntries.forEach(entry => {              const [notation, time] = entry.split(',');              if (time) {                moves.push({ time: parseFloat(time), timeSpent: parseFloat(time), time_spent: parseFloat(time) });              }            });          }        } else if (Array.isArray(result.moves)) {          moves = result.moves;        }        // Sum up the time from all moves        moves.forEach((move) => {          // Accept different time property formats: time_spent (snake_case), timeSpent (camelCase), or time          const moveTime = move.time_spent || move.timeSpent || move.time || 0;          if (moveTime > 0) {            durationSeconds += moveTime;          }        });        console.log('Duration from moves sum:', durationSeconds, 'seconds from', moves.length, 'moves');      }      // Method 2: Fallback to timestamp differences if no moves data      if (durationSeconds === 0) {        if (result.last_move_at && result.created_at) {          const duration = new Date(result.last_move_at).getTime() - new Date(result.created_at).getTime();          durationSeconds = Math.round(duration / 1000);          console.log('Duration from last_move_at - created_at:', durationSeconds, 'seconds');        } else if (result.played_at && result.ended_at) {          // Use played_at and ended_at for more accurate duration          const duration = new Date(result.ended_at).getTime() - new Date(result.played_at).getTime();          durationSeconds = Math.round(duration / 1000);          console.log('Duration from ended_at - played_at:', durationSeconds, 'seconds');        } else if (result.played_at) {          // Fallback: use current time minus played_at time (but cap at reasonable game duration)          const duration = Date.now() - new Date(result.played_at).getTime();          durationSeconds = Math.round(duration / 1000);          // Cap at 2 hours to avoid showing huge durations for old games          durationSeconds = Math.min(durationSeconds, 7200);          console.log('Duration from Date.now() - played_at:', durationSeconds, 'seconds');        }      }      // Ensure we have a valid positive duration      if (durationSeconds < 0) {        durationSeconds = 0;      }      const minutes = Math.floor(durationSeconds / 60);      const seconds = Math.floor(durationSeconds % 60);      gameDurationText = minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;      console.log('Final duration text:', gameDurationText);    } catch (error) {      console.error('Error calculating game duration:', error);      gameDurationText = '0m 0s';    }    return { isPlayerWin, isDraw, playersInfo, resultText, icon, title, gameDurationText };  }, [result, user, score, opponentScore, playerColor, isMultiplayer, computerLevel, isAuthenticated]);  const handleAvatarError = (e: React.SyntheticEvent<HTMLImageElement, Event>, name: string, background: string) => {    e.currentTarget.src = `https://ui-avatars.com/api/?name=${encodeURIComponent(name)}&background=${background}&color=fff&size=128`;  };  const PlayerCard: React.FC<{ player: typeof result.white_player; isCurrentUser: boolean; color: 'white' | 'black', score: number }> = ({ player, isCurrentUser, color, score }) => (    <div className={`flex flex-col sm:flex-row items-center gap-3 p-3 rounded-xl shadow-lg w-full max-w-xs transition-all duration-300 ${isCurrentUser ? 'bg-yellow-50 border-2 border-yellow-400' : 'bg-white border-2 border-gray-200'}`}>      <div className="relative flex-shrink-0">        {player.isComputer ? (          // Computer avatar - show emoji          <div className="w-16 h-16 rounded-full border-4 flex items-center justify-center text-3xl bg-gradient-to-br from-gray-100 to-gray-200"               style={{ borderColor: isCurrentUser ? '#FBBF24' : (color === 'white' ? '#E5E7EB' : '#4B5563') }}>            ðŸ¤–          </div>        ) : (          // Human avatar - show image          <img            src={player.avatar_url}            alt={player.name}            className="w-16 h-16 rounded-full border-4 object-cover"            style={{ borderColor: isCurrentUser ? '#FBBF24' : (color === 'white' ? '#E5E7EB' : '#4B5563') }}            onError={(e) => handleAvatarError(e, player.name, color === 'white' ? '4f46e5' : '1f2937')}            crossOrigin="anonymous"          />        )}        <div className={`absolute -bottom-1 -right-1 text-2xl`}>{color === 'white' ? 'â™”' : 'â™š'}</div>      </div>      <div className="flex-grow text-center sm:text-left">        <div className="font-bold text-gray-800 text-lg">          {player.name} {isCurrentUser && <span className="text-sm font-medium text-yellow-600">(You)</span>}        </div>        <div className="text-sm text-gray-500">          Rating: {player.rating} {player.is_provisional && <span className="text-yellow-500 font-bold">?</span>}        </div>      </div>      <div className="player-card-score-circle">        {typeof score === 'number' ? score.toFixed(1) : '0.0'}      </div>    </div>  );  return (    <div      className={`game-end-card max-w-4xl w-full rounded-2xl shadow-2xl p-4 sm:p-8 text-gray-800 overflow-hidden relative ${className}`}      style={{        backgroundImage: `linear-gradient(rgba(255, 255, 255, 0.97), rgba(255, 255, 255, 0.99)), url(${chessPlayingKids})`,        backgroundSize: 'cover',        backgroundPosition: 'center',      }}    >      <div className="card-branding-header">        <img src={logo} alt="Chess99" className="card-logo" />      </div>      <div className={`result-icon text-7xl text-center animate-bounce ${isPlayerWin ? "text-yellow-500" : "text-gray-500"}`}>        {icon}      </div>      <h1 className="result-title text-4xl sm:text-5xl font-extrabold text-center my-2">{title}</h1>      <div className="result-details">        <p className="result-text text-center text-lg text-gray-600 mb-6">{resultText}</p>        <div className="flex flex-col md:flex-row items-center justify-center gap-4 my-6">          <PlayerCard            player={playersInfo.white_player}            isCurrentUser={playersInfo.hasUser && playersInfo.isUserWhite}            color="white"            score={playersInfo.isUserWhite ? (score !== undefined ? score : (result.final_score || result.finalScore || 0)) : (opponentScore !== undefined ? opponentScore : (result.opponent_score || 0))}          />          <div className="vs-separator text-4xl font-black text-gray-300 my-2 md:my-0">VS</div>          <PlayerCard            player={playersInfo.black_player}            isCurrentUser={playersInfo.hasUser && playersInfo.isUserBlack}            color="black"            score={playersInfo.isUserBlack ? (score !== undefined ? score : (result.final_score || result.finalScore || 0)) : (opponentScore !== undefined ? opponentScore : (result.opponent_score || 0))}          />        </div>        <div className="game-stats flex justify-around items-center mt-6 bg-gray-50 p-3 rounded-xl border border-gray-200 shadow-inner">          <div className="text-center">            <span className="stat-label text-sm text-gray-500">Moves</span>            <span className="stat-value block font-bold text-xl">              {result.move_count || (result.moves ?                (typeof result.moves === 'string' ?                  result.moves.split(';').length :                  (Array.isArray(result.moves) ? result.moves.length : '?')                ) : '?')              }            </span>          </div>          <div className="text-center">            <span className="stat-label text-sm text-gray-500">Duration</span>            <span className="stat-value block font-bold text-xl">{gameDurationText}</span>          </div>          <div className="text-center">            <span className="stat-label text-sm text-gray-500">Result</span>            <span className="stat-value block font-bold text-xl capitalize">{result.end_reason || result.result?.end_reason || 'unknown'}</span>          </div>        </div>        {ratingUpdate && (          <div className="rating-update-display mt-6">            {ratingUpdate.isLoading ? (              <p className="text-center text-gray-500">Calculating rating...</p>            ) : ratingUpdate.error ? (              <p className="text-center text-red-500">{ratingUpdate.error}</p>            ) : ratingUpdate.newRating !== null && ratingUpdate.ratingChange !== null && (              <div className="flex items-center justify-center gap-4 bg-white p-3 rounded-xl border border-gray-200 shadow-sm">                <div className="rating-label font-semibold">Your Rating:</div>                <div className="flex items-baseline gap-2">                  <span className="text-gray-500 line-through">{ratingUpdate.oldRating}</span>                  <span className={`font-bold ${ratingUpdate.ratingChange >= 0 ? 'text-green-500' : 'text-red-500'}`}>                    {ratingUpdate.ratingChange >= 0 ? 'â†‘' : 'â†“'} {Math.abs(ratingUpdate.ratingChange)}                  </span>                  <span className="text-2xl font-bold text-gray-800">{ratingUpdate.newRating}</span>                </div>              </div>            )}          </div>        )}                <div className="call-to-action mt-8 p-5 bg-yellow-100/60 border-2 border-dashed border-yellow-300 rounded-xl text-center">            <div className="flex items-center justify-center gap-3">                <span className="text-3xl">{playersInfo.hasUser ? (isPlayerWin ? "ðŸ†" : isDraw ? "ðŸ¤" : "â™Ÿï¸") : "ðŸ†"}</span>                <span className="font-semibold text-yellow-900">                { playersInfo.hasUser                    ? (isPlayerWin                        ? `Congratulations on your victory! Think you can win again?`                        : isDraw                        ? `That was a close match! Ready for a rematch?`                        : `Every game is a learning opportunity. Challenge ${playersInfo.opponentPlayer.name} again!`)                    : (isDraw                        ? `An intense draw! Think you can do better?`                        : `An exciting game! Think you can beat these players?`)                }                </span>            </div>            <div className="mt-2 text-sm text-yellow-800">                {playersInfo.hasUser                    ? `ðŸ’ª Want to challenge ${playersInfo.opponentPlayer.name}? Or try to beat this performance! ðŸš€`                    : `ðŸ’ª Ready to test your skills? Play and share your results! ðŸš€`                }            </div>            <div className="mt-3 pt-3 border-t-2 border-dashed border-yellow-300/70 font-bold text-yellow-900/80 text-sm">                ðŸ“± Share this result and let others try to beat you!            </div>        </div>        <div className="card-branding-footer mt-8 pt-6 text-center">            <div className="h-0.5 bg-gradient-to-r from-transparent via-yellow-400 to-transparent mb-5"></div>            <div className="bg-gradient-to-br from-gray-50 to-gray-100 rounded-xl p-4 border-2 border-yellow-400 shadow-lg">                <p className="text-sm font-semibold text-gray-700 uppercase tracking-wider mb-2">Want to test your chess skills?</p>                <div className="flex flex-col items-center gap-1">                    <span className="text-xs text-gray-500">Register and Try me at</span>                    <a href="https://www.chess99.com" target="_blank" rel="noopener noreferrer" className="text-xl font-bold text-blue-700 hover:text-blue-500 transition-transform hover:scale-105 p-1 rounded-md">                        www.chess99.com                    </a>                </div>            </div>        </div>      </div>    </div>  );};export default GameEndCard;